---
class: heading_no_counter
draft: false

---

# CAN包装

协议基础依然相同，不再过多介绍，必须先阅读[基础消息结构](/YoroMCU-OTA/zh_hans/)。

针对 CAN 通信，由于有总线仲裁机制的存在，可以不必考虑总线竞争问题，天然支持单对多总线烧录。

## 对CAN总线的限制

基于协议基础，必须以拓展帧收发 CAN 消息，**控制消息(4字节)**对应 CAN 帧 ID，**额外信息(n字节)**对应 CAN 帧数据最多为8个字节。

## 请求单帧结构

| 控制消息(4字节)  | 额外消息(n字节)  |
| ---------------- | ---------------- |
| **基础消息结构** | **基础消息结构** |

示例帧

```c
/* 控制信息 */
05 FA 04 01 // 此为CAN帧ID

/* 额外消息，无实际意义，握手时控制信息已经可以表达所有有效信息 */
00 01 00 00 00 00 00 00 // 此为CAN帧数据
```

## 回复单帧结构

| 控制消息(4字节)  | 回复状态(8字节)  |
| ---------------- | ---------------- |
| **基础消息结构** | **基础消息结构** |

示例帧 对上面握手消息的回复为

```c
/* 控制信息 */
00 FA 80 41 // 此为CAN帧ID

/* 回复状态 */
00 01 00 06 00 00 00 00 // 此为CAN帧数据
```

##  单对单烧录流程

沿用**基础消息结构**中介绍过的最简烧录流程

1. **0xFA 命令烧录**(或者其他特有命令)，此时需要从APP跳入OTA程序
2. **0xFA 再次命令烧录**，作为ping功能，区别在于**回复状态**的头两个字节，跳转回复是00 01，而ping是00 02，表达已经在OTA程序中
3. **0xF4 擦除指示**，将固件需要的部分ROM全部擦掉
4. **0xF7 首包指示**，指示接下来的烧录起始、烧录长度、烧录校验
5. **许多 0xF5 包**，符合指示的长度，但是 OTA 会寄存最开始数个字节而不烧录，使得 APP 不完整。
6. **反复进行 3、4 直到上位机认为完成**
7. **此时 OTA 程序自校验**是否长度、校验都符合，写入最开始的数个字节，使得 APP 完整。
8. **0xF8 上位机发起重启跳转**，接收到确认回复，完成烧录

##  单对多广播烧录流程

在总线上广播烧录，需要解决总线抢占和非烧录机器的静默问题。非烧录机应该进行特定自有的静默态，仅监控接收而不在总线上发送消息，仅对退出静默态的命令进行处理。

1. **0xFA 命令烧录**(或者其他特有命令)，此时需要被烧录机从APP跳入OTA程序，非烧录机进入总线静默。
2. **0xF3 命令统计记录**，对实际需要烧录的机器进行记录，便于回复的校验。
3. **0xFA 再次命令烧录**，作为ping功能，区别在于**回复状态**的头两个字节，跳转回复是00 01，而ping是00 02，表达已经在OTA程序中
4. **0xF4 擦除指示**，将固件需要的部分ROM全部擦掉
5. **0xF7 首包指示**，指示接下来的烧录起始、烧录长度、烧录校验
6. **许多 0xF5 包**，符合指示的长度，但是 OTA 会寄存最开始数个字节而不烧录，使得 APP 不完整。
7. **反复进行 3、4 直到上位机认为完成**
8. **此时 OTA 程序自校验**是否长度、校验都符合，写入最开始的数个字节，使得 APP 完整。
9. **0xF8 上位机发起重启跳转**，接收到确认回复，完成烧录