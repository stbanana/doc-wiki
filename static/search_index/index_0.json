{"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_Error_Get.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Error_Get ### source ```c uint32_t MBx_Master_Error_Get(_MBX_MASTER *pMaster, uint8_t *Func, uint8_t *Error, uint16_t *AddrStart, uint16_t *RegNum ); ``` 从 MBX 主机错误队列中获得一个错误，这个错误是接收到的从机错误码。 ### 传参 > pMaster：期望操作的MBX主机对象指针。 > Func：该错误指令，发送时功能码。 > Error：实际收到的错误码。 > AddrStart：该错误指令，发送时操作的起始地址。 > RegNum：该错误指令，发送时操作的寄存器数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_EMPTY(0x21)：队列为空。"},"/modbusX/zh_hans/apidoc/tools/用户配置文件.html":{"title":"","content":" class: heading_no_counter draft: false # 用户配置文件 ## 重点 协议栈对功能的裁剪和配置应当是很容易的事情，以控制软件包的资源用量。 在 `common/include` 下有 `MBx_user_sample.h` 文件，将其复制一份并且重命名为 `MBx_user.h` ，加入可被 include 找到的路径。 在编译全局 `define` 增加 **MBX_INCLUDE_USER_DEFINE_FILE** ，这样库内就会使用 `MBx_user.h` 的各自定义而非默认。 由于配置文件符合 [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)，可以使用 `vscode` 的插件或者其他方式对 `MBx_user.h` 配置进行渲染，进行更直观的配置，推荐的方法就是 `vscode` 的 `Arm CMSIS Solution` 插件 安装完成，打开 `MBx_user.h` 文件后，点击右上角的 \"Open Preview\" 图标，即可渲染配置文件进行图形化配置。 ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310833976_配置渲染入口图标.png) ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310836815_配置渲染.png) ## 配置细则 ### MBX_MODULE_TCP_MASTER_ENABLE 默认 1 如果使用 modbus TCP 的主机功能需要将这个宏置为 1，否则推荐是置 0，会明显减少资源的占用(主要是 RAM)。 ### MBX_EXTEN_REG_HANDLE_ENABLE 默认 0 注意到在库内给出的例程，所有不同的映射变量，需要独立且尽可能唯一的处理函数。 如果需要在某一个处理函数中处理来自不同的 modbus 虚拟地址的请求，那么这个宏应该置为 1。这个宏置 1 后需要更改映射表的条目(每个条目增加了一个传参集)，并且每个写时回调应该以新的方式编写，后面会详细介绍。 一个明显的适用场景是，作为 modbus 从机，但这个从机只是中间件，需要控制多个完全相同的模块实例，那么这个宏的开启将极大缩减工作量并降低维护难度。针对这样的应用场景有如下的实践案例。 **原本的部分映射表**如下，这三个地址分别控制了三个完全一样的模块， ```c {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower1,}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower2,}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower3,}, ``` 需要编写三个几乎一致的回调，类似如下。虽然可以使用宏生成函数等其他手段，但仍然是难以统一维护的。 ```c uint32_t ModbusModulePower1(void *value) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* 忽略一些开机操作 */ Powerflag[0] 1; } else { /* 忽略一些关机操作 */ Powerflag[0] 1; } return MBX_API_RETURN_DEFAULT; } ``` 而开启这个宏后，需要**更新这部分映射表**如下 ```c const _MBX_REG_HANDLE_PARA MBXPara1 {.Para1 1, .Para2 1}; const _MBX_REG_HANDLE_PARA MBXPara2 {.Para1 2, .Para2 2}; const _MBX_REG_HANDLE_PARA MBXPara3 {.Para1 3, .Para2 3}; ...... {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara1}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara2}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara3}, ``` 这里增加了三个全局静态量，作为参数集，同时每个映射条目需要增加 `.Para` 部分的绑定，这个参数集会传递给写时处理函数，这样使得三个完全一模一样的模块不必定义三个几乎一样的处理函数，而可以调用同一个，所以处理函数的定义需要更新为如下 ```c uint32_t ModbusModulePower(void *value, _MBX_REG_HANDLE_PARA *para) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* 执行 para >Para1 编号模块的开机操作 */ Powerflag[para >Para1 1] 1; } else { /* 执行 para >Para1 编号模块的关机操作 */ Powerflag[para >Para1 1] 1; } return MBX_API_RETURN_DEFAULT; } ``` 对于不使用这个传参的条目，最佳方法是将 `.Para &DefaultPara` 这个 `DefaultPara` 是一个开启宏后会产生的静态量，避免野指针。"},"/modbusX/zh_hans/apidoc/apigengric/Addr_Map.html":{"title":"","content":" class: heading_no_counter draft: false # 地址表的制作 库的重要特色就是将 modbus 地址和已有变量映射起来 ![MBX模型.png](https://cloudflare imgbed 6qt.pages.dev/file/1733793623876_MBX模型.png) 所以无论主机或从机，都需要制作映射表。详情建议参见 [项目自述文件](https://github.com/stbanana/modbusX) 中的库使用步骤。"},"/modbusX/zh_hans/apidoc/apigengric/MBx_Ticks.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Ticks ### source ```c void MBx_Ticks( uint32_t Cycle ); ``` 必须周期调用, 驱动 modbusX 系统的关键函数。无论主机还是从机，均由这个唯一的库tick进行驱动。 ### 传参 > Cycle：调用本函数的周期值us ### 返回值 > 无返回"},"/modbusX/zh_hans/overview/特性.html":{"title":"库特性","content":"# 库特性 1. ⚡**不阻塞**：使用库 tick，禁止阻塞 2. 🪶**不占线程**：单 tick 驱动整个主从链，以任何方式周期运行 tick 3. 🌠**不占中断**：自由的 port 绑定，以任意方式管理数据流 4. 💪**多主多从**：任何主机或从机都是独立对象，可在程序中开启任意多个主从机 5. 🗽**寄存器地址表与内存地址任意映射**：本库的重要特性，解决 modbus 虚拟地址与实际变量之间的映射关系，使得开发更为简单且自由，整个库的使用完全围绕这个映射表展开，未来的维护同样只需维护映射表。 6. ⚖️**不同的地址映射查找时间，相差应当不超过 500 个时钟周期**：很难说是实现了，由于 modbus 最多也就 0xFFFF 个虚拟地址，所以采用了二分法查找，但这样还是不够自由便利，未来会找到更好的表查找结构(或许)。这是库升级的难点，有方案的请与我联系，非常感谢😘！ 7. 🏃‍♀️**克制的事件回调**：少量的回调机制。尽可能使用栈轮询，尽可能少地影响系统时序。"},"/modbusX/zh_hans/apidoc/apislave/MBx_Slave_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_TCP_Init ### source ```c uint32_t MBx_Slave_TCP_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 TCP 初始化 MBX 从机对象，并传入各种配置参数对这个 _MBX_SLAVE 类型从机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的从机对象指针。 > SlaveID：该从机对象配置为的从机 ID ，范围 1~247 。 > MAP：该头指针指向以 MBX_MAP_LIST_END 宏为结尾的 list 表。定义所有可能的地址。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条请求的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条回复的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_MAP_UNFORMAT(0x101)：传入的MAP表不规范"},"/modbusX/zh_hans/apidoc/apislave/MBx_Slave_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_RTU_Init ### source ```c uint32_t MBx_Slave_RTU_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 RTU 初始化 MBX 从机对象，并传入各种配置参数对这个 _MBX_SLAVE 类型从机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的从机对象指针。 > SlaveID：该从机对象配置为的从机 ID ，范围 1~247 。 > MAP：该头指针指向以 MBX_MAP_LIST_END 宏为结尾的 list 表。定义所有可能的地址。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > BaudRate：实际串行链路的波特率，用于自动计算 1.5 字符和 3.5 字符时间。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条请求的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条回复的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_MAP_UNFORMAT(0x101)：传入的MAP表不规范"},"/modbusX/zh_hans/index.html":{"title":"","content":" update: date: 2024 12 07 author: yono version: 0.3.0 content: 完成 gitbook 到 teedoc 的迁移 update_open: false # 规范 文档排版符合 [中文文案排版指北 (github.com)](https://github.com/sparanoid/chinese copywriting guidelines) 开源协议符合 [MIT License (mit license.org)](https://mit license.org/) 实现 MODBUS 协议库符合 [MODBUS Application Protocol 1 1 b](https://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf) 配置文件符合 [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)"},"/modbusX/zh_hans/SUMMARY.html":{"title":"Table of contents","content":"# Table of contents * [库特性](overview/特性.html) * [通用常用API](top/通用常用API.html) \t* [MBx_Ticks](apidoc/apigengric/MBx_Ticks.html) * [从机常用API](top/从机常用API.html) \t* [MBx_Slave_RTU_Init](apidoc/apislave/MBx_Slave_RTU_Init.html) \t* [MBx_Slave_TCP_Init](apidoc/apislave/MBx_Slave_TCP_Init.html) * [主机常用API](top/主机常用API.html) \t* [MBx_Master_RTU_Init](apidoc/apimaster/MBx_Master_RTU_Init.html) \t* [MBx_Master_Member_Add](apidoc/apimaster/MBx_Master_Member_Add.html) \t* [MBx_Master_Error_Get](apidoc/apimaster/MBx_Master_Error_Get.html) \t* [对从机发起请求 系列API](apidoc/apimaster/Master2Slave.html) * [实用功能](top/实用功能.html) \t* [用户配置文件](apidoc/tools/用户配置文件.html)"},"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_TCP_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 TCP 初始化 MBX 主机对象，并传入各种配置参数对这个 _MBX_MASTER 类型主机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的主机对象指针。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条从机回复的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条主机请求的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_ERR_PARAM(0x02)：传参异常，检查调用时的传参。"},"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_RTU_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 RTU 初始化 MBX 主机对象，并传入各种配置参数对这个 _MBX_MASTER 类型主机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的主机对象指针。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > BaudRate：实际串行链路的波特率，用于自动计算 1.5 字符和 3.5 字符时间。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条从机回复的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条主机请求的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_ERR_PARAM(0x02)：传参异常，检查调用时的传参。"},"/modbusX/zh_hans/apidoc/apimaster/Master2Slave.html":{"title":"","content":" class: heading_no_counter draft: false # 对从机发起请求 系列API ## **MBx_Master_Read_Coil_Request** ```c uint32_t MBx_Master_Read_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读线圈请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Read_Disc_Input_Request** ```c uint32_t MBx_Master_Read_Disc_Input_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读离散输入请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Read_Reg_Request** ```c uint32_t MBx_Master_Read_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读保持寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Read_Input_Reg_Request** ```c uint32_t MBx_Master_Read_Input_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读输入寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Coil_Request** ```c uint32_t MBx_Master_Write_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` MBX 主机发出一条写单个线圈请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > Addr：写入地址。 > Value：写入值。写入线圈，本质上只有0与大于0，程序会自动处理格式化请求。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Reg_Request** ```c uint32_t MBx_Master_Write_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` MBX 主机发出一条写单个保持寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > Addr：写入地址。 > Value：写入值。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Coil_Mul_Request** ```c uint32_t MBx_Master_Write_Coil_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` MBX 主机发出一条写多个线圈请求 ，Data、DataLen传参需要自行格式化 见其中关于\"(0x0F)写多个线圈的格式 \" [modbus协议介绍 ](https://www.yono233.cn/posts/shoot/24_7_26_modbus协议介绍(未完成)) ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：写入起始地址。 > WriteNum：写入数量。 > Data：写入数据起始指针。 > DataLen：写入数据长度[字节数]。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Reg_Mul_Request** ```c uint32_t MBx_Master_Write_Reg_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` MBX 主机发出一条写多个保持寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：写入起始地址。 > WriteNum：写入数量。 > Data：写入数据起始指针。 > DataLen：写入数据长度[字节数]。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 "},"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_Member_Add.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Member_Add ### source ```c uint32_t MBx_Master_Member_Add(_MBX_MASTER *MBxMaster, _MBX_MASTER_TEAM_MEMBER *MBxMember, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP ); ``` 向 MBX 主机对象添加一个成员从机 ### 传参 > MBxMaster：期望添加到的MBX主机对象指针 > MBxMember：期望配置并添加进的从机成员对象指针 > SlaveID：从机 ID 。将配置给从机成员 > MAP：该头指针指向以 MBX_MAP_LIST_END 宏为结尾的 list 表。定义所有可能的地址。将配置给从机成员。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_ERR_PARAM(0x02)：传参异常，检查调用时的传参。 > MBX_API_RETURN_MAP_UNFORMAT(0x101)：传入的MAP表不规范"}}