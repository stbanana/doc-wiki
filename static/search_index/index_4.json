{"/Dataflow/en/index.html":{"title":"","content":" update: date: 2024 12 25 author: yono version: 0.1.0 content: Basic update_open: true This library is intended to complement the practical aspects of [modbusX](/modbusX/en/) ， assist in the development of peripheral drivers. The total time is about 5 hours, and there are still many shortcomings. # Effects Hope to help those who can not manage the following two small white, conform to any one can use this library to solve. > DMA of the transport stream. > > Half duplex usage of transport streams. A typical application scenario is the serial port RS485 communication. # Side effects >**Latency**: Introduces an additional 1 2ms delay between sending and receiving data, mainly to ensure the stability of switching half duplex directions. > >**Resources**: Doubles RAM space consumption."},"/Dataflow/en/apidoc/DFlow_Init.html":{"title":"","content":" class: heading_no_counter draft: false # DFlow_Init ### source ```c uint32_t DFlow_Init(_DFlow *df, void *AllBuffer, uint32_t TBufferLen, uint32_t RBufferLen, _DFLOW_COMMON_FUNCTION *Func ); ``` Initialize the DFlow object and pass it various configuration parameters. ### Parameters > df：DFlow object。 > AllBuffer：All available memory areas are used to allocate buffers for Tx and Rx. Note: The memory area must be no smaller than `TBufferLen * 2 + RBufferLen * 2`. > TBufferLen：The length of a single TxBuffer. > RBufferLen：The length of a single RxBuffer. > Func：The port function collection pointer, that is, an additional variable, binds a number of port functions and binds them uniformly to the DFlow object. ### Return Value > DFLOW_API_RETURN_DEFAULT(0x00)：Normal return. > DFLOW_API_RETURN_ERR_PARAM(0x02)：Passing parameters does not meet the requirements; for example, some required port functions are not bind."},"/Dataflow/en/apidoc/DFlow_WR_API.html":{"title":"","content":" class: heading_no_counter draft: false # Sending and receiving data series API ## DFlow_Write ### source ```c uint32_t DFlow_Write(_DFlow *df, uint8_t *pcBuf, uint32_t ui32Len ); ``` Send a piece of data using a DFlow object. It actually pushes the buffer to be sent and sends it all when the time is right. ### Parameters > df：DFlow object to be sent > pcBuf：Buffer header of the data expected to be sent > ui32Len：Len of the data to be sent ### Return Value > DFLOW_API_RETURN_DEFAULT(0x00)：Normal return > DFLOW_API_RETURN_BUFFER_FULL(0x20)：Buffer to be sent is full ## DFlow_Writec ### source ```c uint32_t DFlow_Writec(_DFlow *df, uint8_t data ); ``` Send a byte using some DFlow object. It actually pushes the buffer to be sent and sends it all when the time is right. ### Parameters > df：DFlow object to be sent > data：Bytes of data expected to be sent ### Return Value > DFLOW_API_RETURN_DEFAULT(0x00)：Normal return > DFLOW_API_RETURN_BUFFER_FULL(0x20)：Buffer to be sent is full ## DFlow_Getc ### source ```c uint32_t DFlow_Writec(_DFlow *df, uint8_t *data_rx ); ``` Take a byte from some DFlow object. Actually get the data from the received buffer. ### Parameters > df：DFlow object from which the data is expected > data_rx：Bytes of data to retrieve ### Return Value > DFLOW_API_RETURN_DEFAULT(0x00)：Normal return > DFLOW_API_RETURN_BUFFER_EMPTY(0x21)：Buffer to be received is empty"},"/Dataflow/en/apidoc/DFlow_Ticks.html":{"title":"","content":" class: heading_no_counter draft: false # DFlow_Ticks ### source ```c void DFlow_Ticks( _DFlow *df ); ``` The key functions that drive the Dataflow system must be called periodically. Only drive the incoming DFlow object, it is recommended to call once in 1ms, but it can also be called in a shorter period, which will slightly increase the CPU consumption and slightly reduce the delay of channel switching. ### Parameters > df：Expectation driven DFlow objects ### Return Value > No return value."},"/Dataflow/en/no_translate.html":{"title":"no translation","content":" title: no translation class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">This page not translated yet</div> <div> <span id \"visit_hint\">Please visit</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}