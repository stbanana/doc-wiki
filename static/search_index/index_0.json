{"/modbusX/zh_hans/overview/特性.html":{"title":"库特性","content":"# 库特性 1. ⚡**不阻塞**：使用库 tick，禁止阻塞 2. 🪶**不占线程**：单 tick 驱动整个主从链，以任何方式周期运行 tick 3. 🌠**不占中断**：自由的 port 绑定，以任意方式管理数据流 4. 💪**多主多从**：任何主机或从机都是独立对象，可在程序中开启任意多个主从机 5. 🗽**寄存器地址表与内存地址任意映射**：本库的重要特性，解决 modbus 虚拟地址与实际变量之间的映射关系，使得开发更为简单且自由，整个库的使用完全围绕这个映射表展开，未来的维护同样只需维护映射表。 6. ⚖️**不同的地址映射查找时间，相差应当不超过 500 个时钟周期**：很难说是实现了，由于 modbus 最多也就 0xFFFF 个虚拟地址，所以采用了二分法查找，但这样还是不够自由便利，未来会找到更好的表查找结构(或许)。这是库升级的难点，有方案的请与我联系，非常感谢😘！ 7. 🏃‍♀️**克制的事件回调**：少量的回调机制。尽可能使用栈轮询，尽可能少地影响系统时序。"},"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_Member_Add.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Member_Add ### source ```c uint32_t MBx_Master_Member_Add(_MBX_MASTER *MBxMaster, _MBX_MASTER_TEAM_MEMBER *MBxMember, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP ); ``` 向 MBX 主机对象添加一个成员从机 ### 传参 > MBxMaster：期望添加到的MBX主机对象指针 > MBxMember：期望配置并添加进的从机成员对象指针 > SlaveID：从机 ID 。将配置给从机成员 > MAP：该头指针指向以 MBX_MAP_LIST_END 宏为结尾的 list 表。定义所有可能的地址。将配置给从机成员。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_ERR_PARAM(0x02)：传参异常，检查调用时的传参。 > MBX_API_RETURN_MAP_UNFORMAT(0x101)：传入的MAP表不规范"},"/modbusX/zh_hans/apidoc/apislave/MBx_Slave_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_RTU_Init ### source ```c uint32_t MBx_Slave_RTU_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 RTU 初始化 MBX 从机对象，并传入各种配置参数对这个 _MBX_SLAVE 类型从机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的从机对象指针。 > SlaveID：该从机对象配置为的从机 ID ，范围 1~247 。 > MAP：该头指针指向以 MBX_MAP_LIST_END 宏为结尾的 list 表。定义所有可能的地址。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > BaudRate：实际串行链路的波特率，用于自动计算 1.5 字符和 3.5 字符时间。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条请求的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条回复的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_MAP_UNFORMAT(0x101)：传入的MAP表不规范"},"/modbusX/zh_hans/apidoc/apislave/MBx_Slave_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_TCP_Init ### source ```c uint32_t MBx_Slave_TCP_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 TCP 初始化 MBX 从机对象，并传入各种配置参数对这个 _MBX_SLAVE 类型从机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的从机对象指针。 > SlaveID：该从机对象配置为的从机 ID ，范围 1~247 。 > MAP：该头指针指向以 MBX_MAP_LIST_END 宏为结尾的 list 表。定义所有可能的地址。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条请求的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条回复的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_MAP_UNFORMAT(0x101)：传入的MAP表不规范"},"/modbusX/zh_hans/apidoc/apigengric/Addr_Map.html":{"title":"","content":" class: heading_no_counter draft: false # 地址表的制作 库的重要特色就是将 modbus 地址和已有变量映射起来 ![MBX模型.png](https://cloudflare imgbed 6qt.pages.dev/file/1733793623876_MBX模型.png) 所以无论主机或从机，都需要制作映射表。详情建议参见 [项目自述文件](https://github.com/stbanana/modbusX) 中的库使用步骤。"},"/modbusX/zh_hans/apidoc/apigengric/MBx_Ticks.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Ticks ### source ```c void MBx_Ticks( uint32_t Cycle ); ``` 必须周期调用, 驱动 modbusX 系统的关键函数。无论主机还是从机，均由这个唯一的库tick进行驱动。 ### 传参 > Cycle：调用本函数的周期值us ### 返回值 > 无返回"},"/modbusX/zh_hans/apidoc/tools/用户配置文件.html":{"title":"","content":" class: heading_no_counter draft: false # 用户配置文件 ## 重点 协议栈对功能的裁剪和配置应当是很容易的事情，以控制软件包的资源用量。 在 `common/include` 下有 `MBx_user_sample.h` 文件，将其复制一份并且重命名为 `MBx_user.h` ，加入可被 include 找到的路径。 在编译全局 `define` 增加 **MBX_INCLUDE_USER_DEFINE_FILE** ，这样库内就会使用 `MBx_user.h` 的各自定义而非默认。 由于配置文件符合 [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)，可以使用 `vscode` 的插件或者其他方式对 `MBx_user.h` 配置进行渲染，进行更直观的配置，推荐的方法就是 `vscode` 的 `Arm CMSIS Solution` 插件 安装完成，打开 `MBx_user.h` 文件后，点击右上角的 \"Open Preview\" 图标，即可渲染配置文件进行图形化配置。 ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310833976_配置渲染入口图标.png) ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310836815_配置渲染.png) ## 配置细则 ### MBX_SLAVE_ENABLE 默认 1 从机功能是否开启 1则开启 0则裁剪去掉从机功能 ### MBX_MASTER_ENABLE 默认 1 主机功能是否开启 1则开启 0则裁剪去掉主机功能 ### MBX_MODULE_TCP_MASTER_ENABLE 默认 1 如果使用 modbus TCP 的主机功能需要将这个宏置为 1，否则推荐是置 0，会明显减少资源的占用(主要是 RAM)。 ### MBX_MASTER_REQUEST_QUEUE_MAX 默认 40 主机请求队列的最大寄存条数，用于连续读写请求，寄存并自动发送处理。此条会显著影响 RAM 占用。 ### MBX_MASTER_MULTI_REG_MAX 默认 127 主机读写多个寄存器的最大个数，用于设定库发出的连续读或连续写指令，最多可指定多少个寄存器，此条会显著影响 RAM 占用。 ### MBX_EXTEN_REG_HANDLE_ENABLE 默认 0 注意到在库内给出的例程，所有不同的映射变量，需要独立且尽可能唯一的处理函数。 如果需要在某一个处理函数中处理来自不同的 modbus 虚拟地址的请求，那么这个宏应该置为 1。这个宏置 1 后需要更改映射表的条目(每个条目增加了一个传参集)，并且每个写时回调应该以新的方式编写，后面会详细介绍。 一个明显的适用场景是，作为 modbus 从机，但这个从机只是中间件，需要控制多个完全相同的模块实例，那么这个宏的开启将极大缩减工作量并降低维护难度。针对这样的应用场景有如下的实践案例。 **原本的部分映射表**如下，这三个地址分别控制了三个完全一样的模块， ```c {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower1,}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower2,}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower3,}, ``` 需要编写三个几乎一致的回调，类似如下。虽然可以使用宏生成函数等其他手段，但仍然是难以统一维护的。 ```c uint32_t ModbusModulePower1(void *value) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* 忽略一些开机操作 */ Powerflag[0] 1; } else { /* 忽略一些关机操作 */ Powerflag[0] 1; } return MBX_API_RETURN_DEFAULT; } ``` 而开启这个宏后，需要**更新这部分映射表**如下 ```c const _MBX_REG_HANDLE_PARA MBXPara1 {.Para1 1, .Para2 1}; const _MBX_REG_HANDLE_PARA MBXPara2 {.Para1 2, .Para2 2}; const _MBX_REG_HANDLE_PARA MBXPara3 {.Para1 3, .Para2 3}; ...... {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara1}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara2}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara3}, ``` 这里增加了三个全局静态量，作为参数集，同时每个映射条目需要增加 `.Para` 部分的绑定，这个参数集会传递给写时处理函数，这样使得三个完全一模一样的模块不必定义三个几乎一样的处理函数，而可以调用同一个，所以处理函数的定义需要更新为如下 ```c uint32_t ModbusModulePower(void *value, _MBX_REG_HANDLE_PARA *para) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* 执行 para >Para1 编号模块的开机操作 */ Powerflag[para >Para1 1] 1; } else { /* 执行 para >Para1 编号模块的关机操作 */ Powerflag[para >Para1 1] 1; } return MBX_API_RETURN_DEFAULT; } ``` 对于不使用这个传参的条目，最佳方法是将 `.Para &DefaultPara` 这个 `DefaultPara` 是一个开启宏后会产生的静态量，避免野指针。"},"/modbusX/zh_hans/apidoc/tools/资源占用测试报告.html":{"title":"","content":" class: heading_no_counter draft: false # 资源占用测试报告 综合来看有以下的资源占用报告 ROM \\ RAM (byte) O0 O3 库本体 20724 \\ 200 10360 \\ 204 1 个从机对象 988 \\ 80 632 \\ 80 1 个映射条目 (静态) 20 \\ 0 20 \\ 0 1 个主机对象 908 \\ 21012 548 \\ 21016 主机成员从机对象，与从机对象类似 未测试 未测试 除此以外，为对象准备的收发 buffer 空间也会占用少量 RAM ，编写复杂的回调函数会占用少量 ROM ，但这些可以自定自控制。 注意到整个库，大部分的内容都使用较少的资源，**只有主机对象占用了大量的 RAM**，这是由于开启了所有占用资源的配置项。 以下会有一个推荐的裁剪过程。 默认用户已经熟读了[用户配置文件](./用户配置文件.html) 的内容，对于资源受限的芯片， > 将 **MBX_MODULE_TCP_MASTER_ENABLE** 置为 0 > 将 **MBX_MASTER_REQUEST_QUEUE_MAX** 置为 32 > 将 **MBX_MASTER_ERROR_QUEUE_MAX** 置为 1 > 将 **MBX_MASTER_MULTI_REG_MAX** 置为 20 会显著降低为这样的资源消耗 0x2400001c g O .bss 0x00000638 MBxMaster RAM (byte) O0 O3 1 个主机对象 1592 1592 **开启所有占用资源的配置选项**，有如下 ROM \\ RAM (byte) O0 O3 : 基准参考1<br />(没有启动文件) 96 \\ 28 96 \\ 28 基准参考2<br />(带有启动文件) 936 \\ 28 924 \\ 28 库本体<br />(仅调用库tick) 21660 \\ 228 11284 \\ 232 库本体 + 1 个从机对象<br />(无映射条目无收发buffer) 22648 \\ 308 11916 \\ 308 库本体 + 1 个从机对象 +<br />1 个映射条目 <br />(无收发buffer)) 22668 \\ 308 11936 \\ 308 库本体 + 1 个从机对象 +<br />1 个映射条目 + 1 个简单回调<br />(无收发buffer)) 22700 \\ 308 11940 \\ 308 库本体 + 1 个主机对象 <br />(无收发buffer，无从机成员)) 22568 \\ 21240 11832 \\ 21244 ## 基准参考1 只链接了必要库的空项目，没有启动文件，无法链接出实际产物 ### O0 优化 ```sh [build] c:/111_apps/msys2/mingw64/bin/../lib/gcc/arm none eabi/12.2.0/../../../../arm none eabi/bin/ld.exe: warning: cannot find entry symbol Reset_Handler; defaulting to 08020000 [build] Memory region Used Size Region Size %age Used [build] FLASH: 96 B 2 MB 0.00% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03优化 ```sh [build] c:/111_apps/msys2/mingw64/bin/../lib/gcc/arm none eabi/12.2.0/../../../../arm none eabi/bin/ld.exe: warning: cannot find entry symbol Reset_Handler; defaulting to 08020000 [build] Memory region Used Size Region Size %age Used [build] FLASH: 96 B 2 MB 0.00% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 基准参考2 只链接了必要库的空项目，有启动文件，链接出实际产物 ### O0 优化 ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 936 B 2 MB 0.04% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03优化 ```sh [build] [4/4 100% :: 1.100] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 924 B 2 MB 0.04% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 库本体资源占用 以下代码测试(不展示启动文件) ```c #include <MBx_api.h> // int main( ) { MBx_Ticks(1); return 0; } ``` ARM GCC 编译测试，库本体，而没有任何一个主从机对象 ### O0 优化 占用 21468 字节 ROM ，200 字节 RAM 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 21660 B 2 MB 1.03% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 228 B 512 KB 0.04% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03优化 占用 11188 字节 ROM ，204 字节 RAM 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11284 B 2 MB 0.54% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 232 B 512 KB 0.04% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个从机对象，简单port，空映射表 以下代码测试(不展示启动文件) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } // int main( ) { /* 初始化modbus从机1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // 从机对象 1, // 从机ID MapList, // 地址映射表 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { MBX_MAP_LIST_END }; ``` ### O0 优化 占用 22552 字节 ROM ，280 字节 RAM ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22648 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [ 4%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11916 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个从机对象，简单port，一个条目映射表，无实际回调函数 以下测试代码(不展示启动文件) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } // int main( ) { /* 初始化modbus从机1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // 从机对象 1, // 从机ID MapList, // 地址映射表 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { {.Addr 0x0001, .Memory &(MBxSlave.Config.MapNum), .Type MBX_REG_TYPE_U16, .Handle NULL, .Para &DefaultPara}, MBX_MAP_LIST_END }; ``` ### O0 优化 ```sh [build] [43/43 100% :: 2.018] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22668 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [2/2 100% :: 1.049] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11936 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个从机对象，简单port，无从机成员对象，无实际回调函数 以下测试代码(不展示启动文件) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } uint32_t ModbusSetFoo(void *value, _MBX_REG_HANDLE_PARA *para) { int16_t ValueGet (*(int16_t *)value); return MBX_API_RETURN_DEFAULT; } // int main( ) { /* 初始化modbus从机1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // 从机对象 1, // 从机ID MapList, // 地址映射表 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { {.Addr 0x0001, .Memory &(MBxSlave.Config.MapNum), .Type MBX_REG_TYPE_U16, .Handle ModbusSetFoo, .Para &DefaultPara}, MBX_MAP_LIST_END }; ``` ### O0 优化 ```sh [build] [2/2 100% :: 1.197] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22700 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [43/43 100% :: 2.079] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11940 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个主机对象，简单port，一个条目映射表，一个实际回调函数 以下测试代码(不展示启动文件) ```c #include <MBx_api.h> _MBX_MASTER MBxMaster; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } int main( ) { /* 初始化modbus主机1 */ if(MBx_Master_RTU_Init(&MBxMaster, // 主机对象 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } ``` ### O0 优化 ```sh [build] [43/43 100% :: 2.056] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22568 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 21240 B 512 KB 4.05% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [43/43 100% :: 2.164] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11832 B 2 MB 0.56% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 21244 B 512 KB 4.05% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ```"},"/modbusX/zh_hans/index.html":{"title":"","content":" update: date: 2024 12 07 author: yono version: 0.3.0 content: 完成 gitbook 到 teedoc 的迁移 update_open: true # 规范 文档排版符合 [中文文案排版指北 (github.com)](https://github.com/sparanoid/chinese copywriting guidelines) 开源协议符合 [MIT License (mit license.org)](https://mit license.org/) 实现 MODBUS 协议库符合 [MODBUS Application Protocol 1 1 b](https://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf) 配置文件符合 [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)"},"/modbusX/zh_hans/apidoc/apimaster/Master2Slave.html":{"title":"","content":" class: heading_no_counter draft: false # 对从机发起请求 系列API ## **MBx_Master_Read_Coil_Request** ```c uint32_t MBx_Master_Read_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读线圈请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Read_Disc_Input_Request** ```c uint32_t MBx_Master_Read_Disc_Input_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读离散输入请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Read_Reg_Request** ```c uint32_t MBx_Master_Read_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读保持寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Read_Input_Reg_Request** ```c uint32_t MBx_Master_Read_Input_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` MBX 主机发出一条读输入寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：读取起始地址。 > ReadNum：读取数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Coil_Request** ```c uint32_t MBx_Master_Write_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` MBX 主机发出一条写单个线圈请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > Addr：写入地址。 > Value：写入值。写入线圈，本质上只有0与大于0，程序会自动处理格式化请求。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Reg_Request** ```c uint32_t MBx_Master_Write_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` MBX 主机发出一条写单个保持寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > Addr：写入地址。 > Value：写入值。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Coil_Mul_Request** ```c uint32_t MBx_Master_Write_Coil_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` MBX 主机发出一条写多个线圈请求 ，Data、DataLen传参需要自行格式化 见其中关于\"(0x0F)写多个线圈的格式 \" [modbus协议介绍 ](https://www.yono233.cn/posts/shoot/24_7_26_modbus协议介绍(未完成)) ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：写入起始地址。 > WriteNum：写入数量。 > Data：写入数据起始指针。 > DataLen：写入数据长度[字节数]。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 ## **MBx_Master_Write_Reg_Mul_Request** ```c uint32_t MBx_Master_Write_Reg_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` MBX 主机发出一条写多个保持寄存器请求 ### 传参 > MBxMaster：期望发出请求的MBX主机对象指针。 > SlaveID：期望请求的从机号。 > StartAddr：写入起始地址。 > WriteNum：写入数量。 > Data：写入数据起始指针。 > DataLen：写入数据长度[字节数]。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_FULL(0x20)：队列已满。 > MBX_API_RETURN_MAP_UNFIND(0x102)：未查找到合适的MAP，通常意味着从机号错误、或请求地址在地址映射表中未定义。 "},"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_RTU_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 RTU 初始化 MBX 主机对象，并传入各种配置参数对这个 _MBX_MASTER 类型主机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的主机对象指针。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > BaudRate：实际串行链路的波特率，用于自动计算 1.5 字符和 3.5 字符时间。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条从机回复的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条主机请求的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_ERR_PARAM(0x02)：传参异常，检查调用时的传参。"},"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_TCP_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` 作为 TCP 初始化 MBX 主机对象，并传入各种配置参数对这个 _MBX_MASTER 类型主机对象进行初始化。 ### 传参 > MBxSlave：期望初始化的主机对象指针。 > MBxSend：另实现的数据发送 port ，是一个函数指针。 > MBxGetc：另实现的数据接收port，是一个函数指针。 > RxBuffer：用于存放接收数据的一段内存空间头指针。 > RxBufferSize：用于存放接收数据的内存空间总长度。这个内存空间决定了解析单条从机回复的最大长度。 > TxBuffer：用于存放发送数据的一段内存空间头指针。 > TxBufferSize：用于存放发送数据的内存空间总长度。这个内存空间决定了发送单条主机请求的最大长度。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回 > MBX_API_RETURN_ERR_PARAM(0x02)：传参异常，检查调用时的传参。"},"/modbusX/zh_hans/apidoc/apimaster/MBx_Master_Error_Get.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Error_Get ### source ```c uint32_t MBx_Master_Error_Get(_MBX_MASTER *pMaster, uint8_t *Func, uint8_t *Error, uint16_t *AddrStart, uint16_t *RegNum ); ``` 从 MBX 主机错误队列中获得一个错误，这个错误是接收到的从机错误码。 ### 传参 > pMaster：期望操作的MBX主机对象指针。 > Func：该错误指令，发送时功能码。 > Error：实际收到的错误码。 > AddrStart：该错误指令，发送时操作的起始地址。 > RegNum：该错误指令，发送时操作的寄存器数量。 ### 返回值 > MBX_API_RETURN_DEFAULT(0x00)：正常返回。 > MBX_API_RETURN_BUFFER_EMPTY(0x21)：队列为空。"}}