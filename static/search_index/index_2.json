{"/modbusX/en/apidoc/apigengric/MBx_Ticks.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Ticks ### source ```c void MBx_Ticks( uint32_t Cycle ); ``` This function must be called periodically and is a key function that drives the modbusX system. Both the master and slave are driven by this unique library tick. ### Parameters > Cycle：The period value in microseconds (us) for calling this function. ### Return Value > No return value."},"/modbusX/en/index.html":{"title":"","content":" update: date: 2024 12 07 author: yono version: 0.3.0 content: gitbook 2 teedoc update_open: true # spec The document formatting [Chinese Copywriting Guidelines (github.com)](https://github.com/sparanoid/chinese copywriting guidelines). The open source license [MIT License (mit license.org)](https://mit license.org/). The implementation of the MODBUS protocol library [MODBUS Application Protocol 1.1b](https://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf). The configuration file [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)."},"/modbusX/en/overview/特性.html":{"title":"Library Features","content":"# Library Features 1. ⚡ **Non blocking**: Uses library ticks to prevent blocking. 2. 🪶 **Thread free**: A single tick drives the entire master slave chain, allowing for periodic execution of ticks in any manner. 3. 🌠 **No interrupt usage**: Free port binding allows for arbitrary management of data flow. 4. 💪 **Multi master and multi slave**: Any master or slave is an independent object, allowing for the activation of any number of masters and slaves in the program. 5. 🗽 **Arbitrary mapping of register address tables to memory addresses**: A key feature of this library, solving the mapping relationship between Modbus virtual addresses and actual variables, making development simpler and more flexible. The entire library usage revolves around this mapping table, and future maintenance will only require updates to the mapping table. 6. ⚖️ **Different address mapping lookup times should not exceed 500 clock cycles**: It is difficult to claim this has been fully achieved. Since Modbus has a maximum of 0xFFFF virtual addresses, a binary search method is used, but this is still not flexible enough. A better table lookup structure will be sought in the future (perhaps). This is a challenge for library upgrades; if you have any solutions, please contact me. Thank you very much! 😘 7. 🏃‍♀️ **Restrained event callbacks**: A minimal number of callback mechanisms. Stack polling is used as much as possible to minimize the impact on system timing."},"/modbusX/en/apidoc/apislave/MBx_Slave_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_TCP_Init ### source ```c uint32_t MBx_Slave_TCP_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX slave object for TCP and pass various configuration parameters to initialize this _MBX_SLAVE type slave object. ### Parameters > MBxSlave: Pointer to the slave object to be initialized. > SlaveID: The slave ID to be configured for this slave object, in the range of 1 to 247. > MAP: A pointer to a list ending with the MBX_MAP_LIST_END macro, defining all possible addresses. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single request that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single response that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_MAP_UNFORMAT(0x101): The provided MAP table is not properly formatted."},"/modbusX/en/apidoc/apislave/MBx_Slave_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_RTU_Init ### source ```c uint32_t MBx_Slave_RTU_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX slave object for RTU and pass various configuration parameters to initialize this _MBX_SLAVE type slave object. ### Parameters > MBxSlave: Pointer to the slave object to be initialized. > SlaveID: The slave ID to be configured for this slave object, in the range of 1 to 247. > MAP: A pointer to a list ending with the MBX_MAP_LIST_END macro, defining all possible addresses. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > BaudRate: The baud rate of the actual serial link, used to automatically calculate the time for 1.5 characters and 3.5 characters. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single request that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single response that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_MAP_UNFORMAT(0x101): The provided MAP table is not properly formatted."},"/modbusX/en/apidoc/apimaster/MBx_Master_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_TCP_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX master object for TCP and pass various configuration parameters to initialize this _MBX_MASTER type master object. ### Parameters > MBxMaster: Pointer to the master object to be initialized. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single slave response that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single master request that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_ERR_PARAM(0x02): Parameter error, check the parameters passed during the call."},"/modbusX/en/apidoc/apimaster/MBx_Master_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_RTU_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX master object for RTU and pass various configuration parameters to initialize this _MBX_MASTER type master object. ### Parameters > MBxMaster: Pointer to the master object to be initialized. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > BaudRate: The baud rate of the actual serial link, used to automatically calculate the time for 1.5 characters and 3.5 characters. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single slave response that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single master request that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_ERR_PARAM(0x02): Parameter error, check the parameters passed during the call."},"/modbusX/en/apidoc/apimaster/Master2Slave.html":{"title":"","content":" class: heading_no_counter draft: false # Initiating Requests to Slave ## **MBx_Master_Read_Coil_Request** ```c uint32_t MBx_Master_Read_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read coil request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Read_Disc_Input_Request** ```c uint32_t MBx_Master_Read_Disc_Input_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read discrete input request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Read_Reg_Request** ```c uint32_t MBx_Master_Read_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read holding register request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Read_Input_Reg_Request** ```c uint32_t MBx_Master_Read_Input_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read input register request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Coil_Request** ```c uint32_t MBx_Master_Write_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` The MBX master issues a write single coil request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > Addr: The address to write to. > Value: The value to write. For coils, the value is essentially either 0 or greater than 0; the program will automatically handle the formatting of the request. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Reg_Request** ```c uint32_t MBx_Master_Write_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` The MBX master issues a write single holding register request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > Addr: The address to write to. > Value: The value to write. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Coil_Mul_Request** ```c uint32_t MBx_Master_Write_Coil_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` The MBX master issues a write multiple coils request. The parameters Data and DataLen need to be formatted by the user. See the section on\"(0x0F)写多个线圈的格式 \"for details. [Introduction to Modbus Protocol](https://www.yono233.cn/posts/shoot/24_7_26_modbus协议介绍(未完成)) ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for writing. > WriteNum: The number of coils to write. > Data: Pointer to the start of the data to write. > DataLen: Length of the data to write [in bytes]. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Reg_Mul_Request** ```c uint32_t MBx_Master_Write_Reg_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` The MBX master issues a write multiple holding registers request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for writing. > WriteNum: The number of coils to write. > Data: Pointer to the start of the data to write. > DataLen: Length of the data to write [in bytes]. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. "},"/modbusX/en/apidoc/apimaster/MBx_Master_Member_Add.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Member_Add ### source ```c uint32_t MBx_Master_Member_Add(_MBX_MASTER *MBxMaster, _MBX_MASTER_TEAM_MEMBER *MBxMember, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP ); ``` Add a member slave to the MBX master object. ## Parameters > MBxMaster: Pointer to the MBX master object to which the member is expected to be added. > MBxMember: Pointer to the slave member object that is expected to be configured and added. > SlaveID: The slave ID to be configured for the member. > MAP: A pointer to a list ending with the MBX_MAP_LIST_END macro, defining all possible addresses to be configured for the member. ## Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_ERR_PARAM(0x02): Parameter error, check the parameters passed during the call. > MBX_API_RETURN_MAP_UNFORMAT(0x101): The provided MAP table is not properly formatted."},"/modbusX/en/apidoc/apimaster/MBx_Master_Error_Get.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Error_Get ### source ```c uint32_t MBx_Master_Error_Get(_MBX_MASTER *pMaster, uint8_t *Func, uint8_t *Error, uint16_t *AddrStart, uint16_t *RegNum ); ``` Get an error from the MBX master error queue. This error corresponds to the error code received from the slave. ### Parameters > pMaster: Pointer to the MBX master object that is expected to be operated on. > Func: The function code of the error instruction sent. > Error: The actual error code received. > AddrStart: The starting address operated on by the error instruction sent. > RegNum: The number of registers operated on by the error instruction sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_EMPTY(0x21): Queue is empty."},"/modbusX/en/apidoc/tools/资源占用测试报告.html":{"title":"","content":" class: heading_no_counter draft: false # 资源占用测试报告 综合来看有以下的资源占用报告 ROM \\ RAM (byte) O0 O3 库本体 20724 \\ 200 10360 \\ 204 1 个从机对象 988 \\ 80 632 \\ 80 1 个映射条目 (静态) 20 \\ 0 20 \\ 0 1 个主机对象 908 \\ 21012 548 \\ 21016 主机成员从机对象，与从机对象类似 未测试 未测试 除此以外，为对象准备的收发 buffer 空间也会占用少量 RAM ，编写复杂的回调函数会占用少量 ROM ，但这些可以自定自控制。 注意到整个库，大部分的内容都使用较少的资源，**只有主机对象占用了大量的 RAM**，这是由于开启了所有占用资源的配置项。 以下会有一个推荐的裁剪过程。 默认用户已经熟读了[用户配置文件](./用户配置文件.html) 的内容，对于资源受限的芯片， > 将 **MBX_MODULE_TCP_MASTER_ENABLE** 置为 0 > 将 **MBX_MASTER_REQUEST_QUEUE_MAX** 置为 32 > 将 **MBX_MASTER_ERROR_QUEUE_MAX** 置为 1 > 将 **MBX_MASTER_MULTI_REG_MAX** 置为 20 会显著降低为这样的资源消耗 0x2400001c g O .bss 0x00000638 MBxMaster RAM (byte) O0 O3 1 个主机对象 1592 1592 **开启所有占用资源的配置选项**，有如下 ROM \\ RAM (byte) O0 O3 : 基准参考1<br />(没有启动文件) 96 \\ 28 96 \\ 28 基准参考2<br />(带有启动文件) 936 \\ 28 924 \\ 28 库本体<br />(仅调用库tick) 21660 \\ 228 11284 \\ 232 库本体 + 1 个从机对象<br />(无映射条目无收发buffer) 22648 \\ 308 11916 \\ 308 库本体 + 1 个从机对象 +<br />1 个映射条目 <br />(无收发buffer)) 22668 \\ 308 11936 \\ 308 库本体 + 1 个从机对象 +<br />1 个映射条目 + 1 个简单回调<br />(无收发buffer)) 22700 \\ 308 11940 \\ 308 库本体 + 1 个主机对象 <br />(无收发buffer，无从机成员)) 22568 \\ 21240 11832 \\ 21244 ## 基准参考1 只链接了必要库的空项目，没有启动文件，无法链接出实际产物 ### O0 优化 ```sh [build] c:/111_apps/msys2/mingw64/bin/../lib/gcc/arm none eabi/12.2.0/../../../../arm none eabi/bin/ld.exe: warning: cannot find entry symbol Reset_Handler; defaulting to 08020000 [build] Memory region Used Size Region Size %age Used [build] FLASH: 96 B 2 MB 0.00% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03优化 ```sh [build] c:/111_apps/msys2/mingw64/bin/../lib/gcc/arm none eabi/12.2.0/../../../../arm none eabi/bin/ld.exe: warning: cannot find entry symbol Reset_Handler; defaulting to 08020000 [build] Memory region Used Size Region Size %age Used [build] FLASH: 96 B 2 MB 0.00% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 基准参考2 只链接了必要库的空项目，有启动文件，链接出实际产物 ### O0 优化 ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 936 B 2 MB 0.04% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03优化 ```sh [build] [4/4 100% :: 1.100] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 924 B 2 MB 0.04% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 库本体资源占用 以下代码测试(不展示启动文件) ```c #include <MBx_api.h> // int main( ) { MBx_Ticks(1); return 0; } ``` ARM GCC 编译测试，库本体，而没有任何一个主从机对象 ### O0 优化 占用 21468 字节 ROM ，200 字节 RAM 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 21660 B 2 MB 1.03% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 228 B 512 KB 0.04% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03优化 占用 11188 字节 ROM ，204 字节 RAM 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11284 B 2 MB 0.54% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 232 B 512 KB 0.04% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个从机对象，简单port，空映射表 以下代码测试(不展示启动文件) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } // int main( ) { /* 初始化modbus从机1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // 从机对象 1, // 从机ID MapList, // 地址映射表 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { MBX_MAP_LIST_END }; ``` ### O0 优化 占用 22552 字节 ROM ，280 字节 RAM ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22648 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [ 4%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11916 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个从机对象，简单port，一个条目映射表，无实际回调函数 以下测试代码(不展示启动文件) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } // int main( ) { /* 初始化modbus从机1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // 从机对象 1, // 从机ID MapList, // 地址映射表 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { {.Addr 0x0001, .Memory &(MBxSlave.Config.MapNum), .Type MBX_REG_TYPE_U16, .Handle NULL, .Para &DefaultPara}, MBX_MAP_LIST_END }; ``` ### O0 优化 ```sh [build] [43/43 100% :: 2.018] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22668 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [2/2 100% :: 1.049] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11936 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个从机对象，简单port，无从机成员对象，无实际回调函数 以下测试代码(不展示启动文件) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } uint32_t ModbusSetFoo(void *value, _MBX_REG_HANDLE_PARA *para) { int16_t ValueGet (*(int16_t *)value); return MBX_API_RETURN_DEFAULT; } // int main( ) { /* 初始化modbus从机1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // 从机对象 1, // 从机ID MapList, // 地址映射表 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { {.Addr 0x0001, .Memory &(MBxSlave.Config.MapNum), .Type MBX_REG_TYPE_U16, .Handle ModbusSetFoo, .Para &DefaultPara}, MBX_MAP_LIST_END }; ``` ### O0 优化 ```sh [build] [2/2 100% :: 1.197] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22700 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [43/43 100% :: 2.079] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11940 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## 一个主机对象，简单port，一个条目映射表，一个实际回调函数 以下测试代码(不展示启动文件) ```c #include <MBx_api.h> _MBX_MASTER MBxMaster; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } int main( ) { /* 初始化modbus主机1 */ if(MBx_Master_RTU_Init(&MBxMaster, // 主机对象 SendPort, // 发送函数 GetcPort, // 接收函数 9600, // 波特率 NULL, // 库内接收buffer分配 84, // 接收buffer最大长度 NULL, // 库内发送buffer分配 84) // 发送buffer最大长度 ! MBX_API_RETURN_DEFAULT) { /* 初始化错误 自行判断返回值差错 */ } MBx_Ticks(1); return 0; } ``` ### O0 优化 ```sh [build] [43/43 100% :: 2.056] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22568 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 21240 B 512 KB 4.05% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3优化 具备启动文件和main函数，在配置文件开启了完全的功能，如下 ```sh [build] [43/43 100% :: 2.164] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11832 B 2 MB 0.56% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 21244 B 512 KB 4.05% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ```"},"/modbusX/en/apidoc/tools/用户配置文件.html":{"title":"","content":" class: heading_no_counter draft: false # **User Configuration File** ## Key point The customization and configuration of the protocol stack should be an easy task to control the resource usage of the software package. In the `common/include` directory, there is a file named `MBx_user_sample.h`. Copy this file and rename it to `MBx_user.h`, and add it to a path that can be included. In the global compilation `define`, add **MBX_INCLUDE_USER_DEFINE_FILE**. This way, the library will use the custom definitions from `MBx_user.h` instead of the defaults. Since the configuration file complies with [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)，, you can use the `vscode` plugin or other methods to render the configuration in `MBx_user.h`, allowing for a more intuitive configuration. The recommended method is to use the `Arm CMSIS Solution` plugin for `vscode`. Once installed, open the `MBx_user.h` file and click the \"Open Preview\" icon in the upper right corner to render the configuration file for graphical configuration. ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310833976_配置渲染入口图标.png) ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310836815_配置渲染.png) ## Particulars ### MBX_SLAVE_ENABLE Default 1 Whether the slave function is open, 1 is open, 0 is cut off the slave function ### MBX_MASTER_ENABLE 默认 1 Whether the master function is open, 1 is open, 0 is cut off the master function ### MBX_MODULE_TCP_MASTER_ENABLE Default 1 If you need to use the Modbus TCP master functionality, this macro should be set to 1. Otherwise, it is recommended to set it to 0, which will significantly reduce resource usage (mainly RAM). ### MBX_MASTER_REQUEST_QUEUE_MAX Default 40 The maximum number of entries in the host request queue for continuous read and write requests, stored and automatically sent for processing. This can significantly affect RAM usage. ### MBX_MASTER_MULTI_REG_MAX Default 127 The maximum number of multiple registers that the host can read and write to sets the maximum number of registers that can be specified for successive read or write instructions issued by the library, which significantly affects RAM usage. ### MBX_EXTEN_REG_HANDLE_ENABLE Default 0 Note that in the examples provided within the library, all different mapped variables require independent and as unique as possible handling functions. If you need to handle requests from different Modbus virtual addresses in a single handling function, this macro should be set to 1. When this macro is set to 1, the mapping table entries need to be modified (each entry will have an additional parameter set), and each write callback should be rewritten in a new way, which will be detailed later. A clear applicable scenario is when acting as a Modbus slave, but this slave is merely middleware that needs to control multiple identical module instances. Enabling this macro will greatly reduce the workload and lower maintenance difficulty. There are practical cases for such application scenarios. **The original mapping table** is as follows, where these three addresses control three identical modules: ```c {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower1,}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower2,}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower3,}, ``` You would need to write three almost identical callbacks, similar to the following. Although macros can be used to generate functions and other means, it is still difficult to maintain uniformly. ```c uint32_t ModbusModulePower1(void *value) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* Ignore some startup operations */ Powerflag[0] 1; } else { /* Ignore some shutdown operations */ Powerflag[0] 1; } return MBX_API_RETURN_DEFAULT; } ``` After enabling this macro, you need to **update this part of the mapping table** as follows: ```c const _MBX_REG_HANDLE_PARA MBXPara1 {.Para1 1, .Para2 1}; const _MBX_REG_HANDLE_PARA MBXPara2 {.Para1 2, .Para2 2}; const _MBX_REG_HANDLE_PARA MBXPara3 {.Para1 3, .Para2 3}; ...... {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara1}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara2}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara3}, ``` Here, three global static variables are added as parameter sets, and each mapping entry needs to include the binding of the `.Para` part. This parameter set will be passed to the write handling function, allowing three identical modules to call the same function without needing to define three almost identical handling functions. Therefore, the definition of the handling function needs to be updated as follows: ```c uint32_t ModbusModulePower(void *value, _MBX_REG_HANDLE_PARA *para) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* Perform startup operation for module identified by para >Para1 */ Powerflag[para >Para1 1] 1; } else { /* Perform shutdown operation for module identified by para >Para1 */ Powerflag[para >Para1 1] 1; } return MBX_API_RETURN_DEFAULT; } ``` For entries that do not use this parameter, the best approach is to set `.Para &DefaultPara`, where `DefaultPara` is a static variable generated when the macro is enabled, to avoid wild pointers."},"/modbusX/en/apidoc/apigengric/Addr_Map.html":{"title":"","content":" class: heading_no_counter draft: false # Creation of Address Tables A key feature of the library is to map Modbus addresses to existing variables. ![MBX_module.png](https://cloudflare imgbed 6qt.pages.dev/file/1733793623876_MBX模型.png) Therefore, whether it's a master or a slave, an address mapping table needs to be created. For detailed instructions, it is recommended to refer to the library usage steps in the [project README file](https://github.com/stbanana/modbusX) ."},"/modbusX/en/no_translate.html":{"title":"no translation","content":" title: no translation class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">This page not translated yet</div> <div> <span id \"visit_hint\">Please visit</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}