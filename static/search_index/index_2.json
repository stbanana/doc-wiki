{"/modbusX/en/apidoc/apigengric/MBx_Ticks.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Ticks ### source ```c void MBx_Ticks( uint32_t Cycle ); ``` This function must be called periodically and is a key function that drives the modbusX system. Both the master and slave are driven by this unique library tick. ### Parameters > Cycleï¼šThe period value in microseconds (us) for calling this function. ### Return Value > No return value."},"/modbusX/en/index.html":{"title":"","content":" update: date: 2024 12 07 author: yono version: 0.3.0 content: gitbook 2 teedoc update_open: true # spec The document formatting [Chinese Copywriting Guidelines (github.com)](https://github.com/sparanoid/chinese copywriting guidelines). The open source license [MIT License (mit license.org)](https://mit license.org/). The implementation of the MODBUS protocol library [MODBUS Application Protocol 1.1b](https://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf). The configuration file [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)."},"/modbusX/en/overview/ç‰¹æ€§.html":{"title":"Library Features","content":"# Library Features 1. âš¡ **Non blocking**: Uses library ticks to prevent blocking. 2. ğŸª¶ **Thread free**: A single tick drives the entire master slave chain, allowing for periodic execution of ticks in any manner. 3. ğŸŒ  **No interrupt usage**: Free port binding allows for arbitrary management of data flow. 4. ğŸ’ª **Multi master and multi slave**: Any master or slave is an independent object, allowing for the activation of any number of masters and slaves in the program. 5. ğŸ—½ **Arbitrary mapping of register address tables to memory addresses**: A key feature of this library, solving the mapping relationship between Modbus virtual addresses and actual variables, making development simpler and more flexible. The entire library usage revolves around this mapping table, and future maintenance will only require updates to the mapping table. 6. âš–ï¸ **Different address mapping lookup times should not exceed 500 clock cycles**: It is difficult to claim this has been fully achieved. Since Modbus has a maximum of 0xFFFF virtual addresses, a binary search method is used, but this is still not flexible enough. A better table lookup structure will be sought in the future (perhaps). This is a challenge for library upgrades; if you have any solutions, please contact me. Thank you very much! ğŸ˜˜ 7. ğŸƒâ€â™€ï¸ **Restrained event callbacks**: A minimal number of callback mechanisms. Stack polling is used as much as possible to minimize the impact on system timing."},"/modbusX/en/apidoc/apislave/MBx_Slave_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_TCP_Init ### source ```c uint32_t MBx_Slave_TCP_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX slave object for TCP and pass various configuration parameters to initialize this _MBX_SLAVE type slave object. ### Parameters > MBxSlave: Pointer to the slave object to be initialized. > SlaveID: The slave ID to be configured for this slave object, in the range of 1 to 247. > MAP: A pointer to a list ending with the MBX_MAP_LIST_END macro, defining all possible addresses. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single request that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single response that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_MAP_UNFORMAT(0x101): The provided MAP table is not properly formatted."},"/modbusX/en/apidoc/apislave/MBx_Slave_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Slave_RTU_Init ### source ```c uint32_t MBx_Slave_RTU_Init(_MBX_SLAVE *MBxSlave, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX slave object for RTU and pass various configuration parameters to initialize this _MBX_SLAVE type slave object. ### Parameters > MBxSlave: Pointer to the slave object to be initialized. > SlaveID: The slave ID to be configured for this slave object, in the range of 1 to 247. > MAP: A pointer to a list ending with the MBX_MAP_LIST_END macro, defining all possible addresses. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > BaudRate: The baud rate of the actual serial link, used to automatically calculate the time for 1.5 characters and 3.5 characters. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single request that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single response that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_MAP_UNFORMAT(0x101): The provided MAP table is not properly formatted."},"/modbusX/en/apidoc/apimaster/MBx_Master_TCP_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_TCP_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX master object for TCP and pass various configuration parameters to initialize this _MBX_MASTER type master object. ### Parameters > MBxMaster: Pointer to the master object to be initialized. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single slave response that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single master request that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_ERR_PARAM(0x02): Parameter error, check the parameters passed during the call."},"/modbusX/en/apidoc/apimaster/MBx_Master_RTU_Init.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_RTU_Init ### source ```c uint32_t MBx_Master_RTU_Init(_MBX_MASTER *MBxMaster, MBX_SEND_PTR MBxSend, MBX_GTEC_PTR MBxGetc, uint32_t BaudRate, uint8_t *RxBuffer, uint32_t RxBufferSize, uint8_t *TxBuffer, uint32_t TxBufferSize ); ``` Initialize the MBX master object for RTU and pass various configuration parameters to initialize this _MBX_MASTER type master object. ### Parameters > MBxMaster: Pointer to the master object to be initialized. > MBxSend: A function pointer for the data sending port. > MBxGetc: A function pointer for the data receiving port. > BaudRate: The baud rate of the actual serial link, used to automatically calculate the time for 1.5 characters and 3.5 characters. > RxBuffer: Pointer to a memory space for storing received data. > RxBufferSize: Total length of the memory space for storing received data. This memory space determines the maximum length of a single slave response that can be parsed. > TxBuffer: Pointer to a memory space for storing data to be sent. > TxBufferSize: Total length of the memory space for storing data to be sent. This memory space determines the maximum length of a single master request that can be sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_ERR_PARAM(0x02): Parameter error, check the parameters passed during the call."},"/modbusX/en/apidoc/apimaster/Master2Slave.html":{"title":"","content":" class: heading_no_counter draft: false # Initiating Requests to Slave ## **MBx_Master_Read_Coil_Request** ```c uint32_t MBx_Master_Read_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read coil request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Read_Disc_Input_Request** ```c uint32_t MBx_Master_Read_Disc_Input_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read discrete input request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Read_Reg_Request** ```c uint32_t MBx_Master_Read_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read holding register request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Read_Input_Reg_Request** ```c uint32_t MBx_Master_Read_Input_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t ReadNum); ``` The MBX master issues a read input register request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for reading. > ReadNum: The number of coils to read. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Coil_Request** ```c uint32_t MBx_Master_Write_Coil_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` The MBX master issues a write single coil request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > Addr: The address to write to. > Value: The value to write. For coils, the value is essentially either 0 or greater than 0; the program will automatically handle the formatting of the request. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Reg_Request** ```c uint32_t MBx_Master_Write_Reg_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t Addr, uint16_t Value); ``` The MBX master issues a write single holding register request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > Addr: The address to write to. > Value: The value to write. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Coil_Mul_Request** ```c uint32_t MBx_Master_Write_Coil_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` The MBX master issues a write multiple coils request. The parameters Data and DataLen need to be formatted by the user. See the section on\"(0x0F)å†™å¤šä¸ªçº¿åœˆçš„æ ¼å¼ \"for details. [Introduction to Modbus Protocol](https://www.yono233.cn/posts/shoot/24_7_26_modbusåè®®ä»‹ç»(æœªå®Œæˆ)) ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for writing. > WriteNum: The number of coils to write. > Data: Pointer to the start of the data to write. > DataLen: Length of the data to write [in bytes]. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. ## **MBx_Master_Write_Reg_Mul_Request** ```c uint32_t MBx_Master_Write_Reg_Mul_Request(_MBX_MASTER *pMaster, uint8_t SlaveID, uint16_t StartAddr, uint16_t WriteNum, uint8_t *Data, uint16_t DataLen); ``` The MBX master issues a write multiple holding registers request. ### Parameters > pMaster: Pointer to the MBX master object that is expected to issue the request. > SlaveID: The ID of the slave to be requested. > StartAddr: The starting address for writing. > WriteNum: The number of coils to write. > Data: Pointer to the start of the data to write. > DataLen: Length of the data to write [in bytes]. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_FULL(0x20): Queue is full. > MBX_API_RETURN_MAP_UNFIND(0x102): Suitable MAP not found, usually means the slave ID is incorrect or the requested address is not defined in the address mapping table. "},"/modbusX/en/apidoc/apimaster/MBx_Master_Member_Add.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Member_Add ### source ```c uint32_t MBx_Master_Member_Add(_MBX_MASTER *MBxMaster, _MBX_MASTER_TEAM_MEMBER *MBxMember, uint8_t SlaveID, const _MBX_MAP_LIST_ENTRY *MAP ); ``` Add a member slave to the MBX master object. ## Parameters > MBxMaster: Pointer to the MBX master object to which the member is expected to be added. > MBxMember: Pointer to the slave member object that is expected to be configured and added. > SlaveID: The slave ID to be configured for the member. > MAP: A pointer to a list ending with the MBX_MAP_LIST_END macro, defining all possible addresses to be configured for the member. ## Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_ERR_PARAM(0x02): Parameter error, check the parameters passed during the call. > MBX_API_RETURN_MAP_UNFORMAT(0x101): The provided MAP table is not properly formatted."},"/modbusX/en/apidoc/apimaster/MBx_Master_Error_Get.html":{"title":"","content":" class: heading_no_counter draft: false # MBx_Master_Error_Get ### source ```c uint32_t MBx_Master_Error_Get(_MBX_MASTER *pMaster, uint8_t *Func, uint8_t *Error, uint16_t *AddrStart, uint16_t *RegNum ); ``` Get an error from the MBX master error queue. This error corresponds to the error code received from the slave. ### Parameters > pMaster: Pointer to the MBX master object that is expected to be operated on. > Func: The function code of the error instruction sent. > Error: The actual error code received. > AddrStart: The starting address operated on by the error instruction sent. > RegNum: The number of registers operated on by the error instruction sent. ### Return Value > MBX_API_RETURN_DEFAULT(0x00): Normal return. > MBX_API_RETURN_BUFFER_EMPTY(0x21): Queue is empty."},"/modbusX/en/apidoc/tools/èµ„æºå ç”¨æµ‹è¯•æŠ¥å‘Š.html":{"title":"","content":" class: heading_no_counter draft: false # èµ„æºå ç”¨æµ‹è¯•æŠ¥å‘Š ç»¼åˆæ¥çœ‹æœ‰ä»¥ä¸‹çš„èµ„æºå ç”¨æŠ¥å‘Š ROM \\ RAM (byte) O0 O3 åº“æœ¬ä½“ 20724 \\ 200 10360 \\ 204 1 ä¸ªä»æœºå¯¹è±¡ 988 \\ 80 632 \\ 80 1 ä¸ªæ˜ å°„æ¡ç›® (é™æ€) 20 \\ 0 20 \\ 0 1 ä¸ªä¸»æœºå¯¹è±¡ 908 \\ 21012 548 \\ 21016 ä¸»æœºæˆå‘˜ä»æœºå¯¹è±¡ï¼Œä¸ä»æœºå¯¹è±¡ç±»ä¼¼ æœªæµ‹è¯• æœªæµ‹è¯• é™¤æ­¤ä»¥å¤–ï¼Œä¸ºå¯¹è±¡å‡†å¤‡çš„æ”¶å‘ buffer ç©ºé—´ä¹Ÿä¼šå ç”¨å°‘é‡ RAM ï¼Œç¼–å†™å¤æ‚çš„å›è°ƒå‡½æ•°ä¼šå ç”¨å°‘é‡ ROM ï¼Œä½†è¿™äº›å¯ä»¥è‡ªå®šè‡ªæ§åˆ¶ã€‚ æ³¨æ„åˆ°æ•´ä¸ªåº“ï¼Œå¤§éƒ¨åˆ†çš„å†…å®¹éƒ½ä½¿ç”¨è¾ƒå°‘çš„èµ„æºï¼Œ**åªæœ‰ä¸»æœºå¯¹è±¡å ç”¨äº†å¤§é‡çš„ RAM**ï¼Œè¿™æ˜¯ç”±äºå¼€å¯äº†æ‰€æœ‰å ç”¨èµ„æºçš„é…ç½®é¡¹ã€‚ ä»¥ä¸‹ä¼šæœ‰ä¸€ä¸ªæ¨èçš„è£å‰ªè¿‡ç¨‹ã€‚ é»˜è®¤ç”¨æˆ·å·²ç»ç†Ÿè¯»äº†[ç”¨æˆ·é…ç½®æ–‡ä»¶](./ç”¨æˆ·é…ç½®æ–‡ä»¶.html) çš„å†…å®¹ï¼Œå¯¹äºèµ„æºå—é™çš„èŠ¯ç‰‡ï¼Œ > å°† **MBX_MODULE_TCP_MASTER_ENABLE** ç½®ä¸º 0 > å°† **MBX_MASTER_REQUEST_QUEUE_MAX** ç½®ä¸º 32 > å°† **MBX_MASTER_ERROR_QUEUE_MAX** ç½®ä¸º 1 > å°† **MBX_MASTER_MULTI_REG_MAX** ç½®ä¸º 20 ä¼šæ˜¾è‘—é™ä½ä¸ºè¿™æ ·çš„èµ„æºæ¶ˆè€— 0x2400001c g O .bss 0x00000638 MBxMaster RAM (byte) O0 O3 1 ä¸ªä¸»æœºå¯¹è±¡ 1592 1592 **å¼€å¯æ‰€æœ‰å ç”¨èµ„æºçš„é…ç½®é€‰é¡¹**ï¼Œæœ‰å¦‚ä¸‹ ROM \\ RAM (byte) O0 O3 : åŸºå‡†å‚è€ƒ1<br />(æ²¡æœ‰å¯åŠ¨æ–‡ä»¶) 96 \\ 28 96 \\ 28 åŸºå‡†å‚è€ƒ2<br />(å¸¦æœ‰å¯åŠ¨æ–‡ä»¶) 936 \\ 28 924 \\ 28 åº“æœ¬ä½“<br />(ä»…è°ƒç”¨åº“tick) 21660 \\ 228 11284 \\ 232 åº“æœ¬ä½“ + 1 ä¸ªä»æœºå¯¹è±¡<br />(æ— æ˜ å°„æ¡ç›®æ— æ”¶å‘buffer) 22648 \\ 308 11916 \\ 308 åº“æœ¬ä½“ + 1 ä¸ªä»æœºå¯¹è±¡ +<br />1 ä¸ªæ˜ å°„æ¡ç›® <br />(æ— æ”¶å‘buffer)) 22668 \\ 308 11936 \\ 308 åº“æœ¬ä½“ + 1 ä¸ªä»æœºå¯¹è±¡ +<br />1 ä¸ªæ˜ å°„æ¡ç›® + 1 ä¸ªç®€å•å›è°ƒ<br />(æ— æ”¶å‘buffer)) 22700 \\ 308 11940 \\ 308 åº“æœ¬ä½“ + 1 ä¸ªä¸»æœºå¯¹è±¡ <br />(æ— æ”¶å‘bufferï¼Œæ— ä»æœºæˆå‘˜)) 22568 \\ 21240 11832 \\ 21244 ## åŸºå‡†å‚è€ƒ1 åªé“¾æ¥äº†å¿…è¦åº“çš„ç©ºé¡¹ç›®ï¼Œæ²¡æœ‰å¯åŠ¨æ–‡ä»¶ï¼Œæ— æ³•é“¾æ¥å‡ºå®é™…äº§ç‰© ### O0 ä¼˜åŒ– ```sh [build] c:/111_apps/msys2/mingw64/bin/../lib/gcc/arm none eabi/12.2.0/../../../../arm none eabi/bin/ld.exe: warning: cannot find entry symbol Reset_Handler; defaulting to 08020000 [build] Memory region Used Size Region Size %age Used [build] FLASH: 96 B 2 MB 0.00% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03ä¼˜åŒ– ```sh [build] c:/111_apps/msys2/mingw64/bin/../lib/gcc/arm none eabi/12.2.0/../../../../arm none eabi/bin/ld.exe: warning: cannot find entry symbol Reset_Handler; defaulting to 08020000 [build] Memory region Used Size Region Size %age Used [build] FLASH: 96 B 2 MB 0.00% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## åŸºå‡†å‚è€ƒ2 åªé“¾æ¥äº†å¿…è¦åº“çš„ç©ºé¡¹ç›®ï¼Œæœ‰å¯åŠ¨æ–‡ä»¶ï¼Œé“¾æ¥å‡ºå®é™…äº§ç‰© ### O0 ä¼˜åŒ– ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 936 B 2 MB 0.04% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03ä¼˜åŒ– ```sh [build] [4/4 100% :: 1.100] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 924 B 2 MB 0.04% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 28 B 512 KB 0.01% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## åº“æœ¬ä½“èµ„æºå ç”¨ ä»¥ä¸‹ä»£ç æµ‹è¯•(ä¸å±•ç¤ºå¯åŠ¨æ–‡ä»¶) ```c #include <MBx_api.h> // int main( ) { MBx_Ticks(1); return 0; } ``` ARM GCC ç¼–è¯‘æµ‹è¯•ï¼Œåº“æœ¬ä½“ï¼Œè€Œæ²¡æœ‰ä»»ä½•ä¸€ä¸ªä¸»ä»æœºå¯¹è±¡ ### O0 ä¼˜åŒ– å ç”¨ 21468 å­—èŠ‚ ROM ï¼Œ200 å­—èŠ‚ RAM å…·å¤‡å¯åŠ¨æ–‡ä»¶å’Œmainå‡½æ•°ï¼Œåœ¨é…ç½®æ–‡ä»¶å¼€å¯äº†å®Œå…¨çš„åŠŸèƒ½ï¼Œå¦‚ä¸‹ ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 21660 B 2 MB 1.03% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 228 B 512 KB 0.04% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### 03ä¼˜åŒ– å ç”¨ 11188 å­—èŠ‚ ROM ï¼Œ204 å­—èŠ‚ RAM å…·å¤‡å¯åŠ¨æ–‡ä»¶å’Œmainå‡½æ•°ï¼Œåœ¨é…ç½®æ–‡ä»¶å¼€å¯äº†å®Œå…¨çš„åŠŸèƒ½ï¼Œå¦‚ä¸‹ ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11284 B 2 MB 0.54% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 232 B 512 KB 0.04% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## ä¸€ä¸ªä»æœºå¯¹è±¡ï¼Œç®€å•portï¼Œç©ºæ˜ å°„è¡¨ ä»¥ä¸‹ä»£ç æµ‹è¯•(ä¸å±•ç¤ºå¯åŠ¨æ–‡ä»¶) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } // int main( ) { /* åˆå§‹åŒ–modbusä»æœº1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // ä»æœºå¯¹è±¡ 1, // ä»æœºID MapList, // åœ°å€æ˜ å°„è¡¨ SendPort, // å‘é€å‡½æ•° GetcPort, // æ¥æ”¶å‡½æ•° 9600, // æ³¢ç‰¹ç‡ NULL, // åº“å†…æ¥æ”¶bufferåˆ†é… 84, // æ¥æ”¶bufferæœ€å¤§é•¿åº¦ NULL, // åº“å†…å‘é€bufferåˆ†é… 84) // å‘é€bufferæœ€å¤§é•¿åº¦ ! MBX_API_RETURN_DEFAULT) { /* åˆå§‹åŒ–é”™è¯¯ è‡ªè¡Œåˆ¤æ–­è¿”å›å€¼å·®é”™ */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { MBX_MAP_LIST_END }; ``` ### O0 ä¼˜åŒ– å ç”¨ 22552 å­—èŠ‚ ROM ï¼Œ280 å­—èŠ‚ RAM ```sh [build] [100%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22648 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3ä¼˜åŒ– å…·å¤‡å¯åŠ¨æ–‡ä»¶å’Œmainå‡½æ•°ï¼Œåœ¨é…ç½®æ–‡ä»¶å¼€å¯äº†å®Œå…¨çš„åŠŸèƒ½ï¼Œå¦‚ä¸‹ ```sh [build] [ 4%] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11916 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## ä¸€ä¸ªä»æœºå¯¹è±¡ï¼Œç®€å•portï¼Œä¸€ä¸ªæ¡ç›®æ˜ å°„è¡¨ï¼Œæ— å®é™…å›è°ƒå‡½æ•° ä»¥ä¸‹æµ‹è¯•ä»£ç (ä¸å±•ç¤ºå¯åŠ¨æ–‡ä»¶) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } // int main( ) { /* åˆå§‹åŒ–modbusä»æœº1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // ä»æœºå¯¹è±¡ 1, // ä»æœºID MapList, // åœ°å€æ˜ å°„è¡¨ SendPort, // å‘é€å‡½æ•° GetcPort, // æ¥æ”¶å‡½æ•° 9600, // æ³¢ç‰¹ç‡ NULL, // åº“å†…æ¥æ”¶bufferåˆ†é… 84, // æ¥æ”¶bufferæœ€å¤§é•¿åº¦ NULL, // åº“å†…å‘é€bufferåˆ†é… 84) // å‘é€bufferæœ€å¤§é•¿åº¦ ! MBX_API_RETURN_DEFAULT) { /* åˆå§‹åŒ–é”™è¯¯ è‡ªè¡Œåˆ¤æ–­è¿”å›å€¼å·®é”™ */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { {.Addr 0x0001, .Memory &(MBxSlave.Config.MapNum), .Type MBX_REG_TYPE_U16, .Handle NULL, .Para &DefaultPara}, MBX_MAP_LIST_END }; ``` ### O0 ä¼˜åŒ– ```sh [build] [43/43 100% :: 2.018] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22668 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3ä¼˜åŒ– å…·å¤‡å¯åŠ¨æ–‡ä»¶å’Œmainå‡½æ•°ï¼Œåœ¨é…ç½®æ–‡ä»¶å¼€å¯äº†å®Œå…¨çš„åŠŸèƒ½ï¼Œå¦‚ä¸‹ ```sh [build] [2/2 100% :: 1.049] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11936 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## ä¸€ä¸ªä»æœºå¯¹è±¡ï¼Œç®€å•portï¼Œæ— ä»æœºæˆå‘˜å¯¹è±¡ï¼Œæ— å®é™…å›è°ƒå‡½æ•° ä»¥ä¸‹æµ‹è¯•ä»£ç (ä¸å±•ç¤ºå¯åŠ¨æ–‡ä»¶) ```c #include <MBx_api.h> static const _MBX_MAP_LIST_ENTRY MapList[]; _MBX_SLAVE MBxSlave; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } uint32_t ModbusSetFoo(void *value, _MBX_REG_HANDLE_PARA *para) { int16_t ValueGet (*(int16_t *)value); return MBX_API_RETURN_DEFAULT; } // int main( ) { /* åˆå§‹åŒ–modbusä»æœº1 */ if(MBx_Slave_RTU_Init(&MBxSlave, // ä»æœºå¯¹è±¡ 1, // ä»æœºID MapList, // åœ°å€æ˜ å°„è¡¨ SendPort, // å‘é€å‡½æ•° GetcPort, // æ¥æ”¶å‡½æ•° 9600, // æ³¢ç‰¹ç‡ NULL, // åº“å†…æ¥æ”¶bufferåˆ†é… 84, // æ¥æ”¶bufferæœ€å¤§é•¿åº¦ NULL, // åº“å†…å‘é€bufferåˆ†é… 84) // å‘é€bufferæœ€å¤§é•¿åº¦ ! MBX_API_RETURN_DEFAULT) { /* åˆå§‹åŒ–é”™è¯¯ è‡ªè¡Œåˆ¤æ–­è¿”å›å€¼å·®é”™ */ } MBx_Ticks(1); return 0; } static const _MBX_MAP_LIST_ENTRY MapList[] { {.Addr 0x0001, .Memory &(MBxSlave.Config.MapNum), .Type MBX_REG_TYPE_U16, .Handle ModbusSetFoo, .Para &DefaultPara}, MBX_MAP_LIST_END }; ``` ### O0 ä¼˜åŒ– ```sh [build] [2/2 100% :: 1.197] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22700 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3ä¼˜åŒ– å…·å¤‡å¯åŠ¨æ–‡ä»¶å’Œmainå‡½æ•°ï¼Œåœ¨é…ç½®æ–‡ä»¶å¼€å¯äº†å®Œå…¨çš„åŠŸèƒ½ï¼Œå¦‚ä¸‹ ```sh [build] [43/43 100% :: 2.079] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11940 B 2 MB 0.57% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 308 B 512 KB 0.06% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ## ä¸€ä¸ªä¸»æœºå¯¹è±¡ï¼Œç®€å•portï¼Œä¸€ä¸ªæ¡ç›®æ˜ å°„è¡¨ï¼Œä¸€ä¸ªå®é™…å›è°ƒå‡½æ•° ä»¥ä¸‹æµ‹è¯•ä»£ç (ä¸å±•ç¤ºå¯åŠ¨æ–‡ä»¶) ```c #include <MBx_api.h> _MBX_MASTER MBxMaster; // uint32_t SendPort(const void *Data, size_t Len) { return MBX_PORT_RETURN_DEFAULT; } uint32_t GetcPort(uint8_t *Data) { return MBX_PORT_RETURN_DEFAULT; } int main( ) { /* åˆå§‹åŒ–modbusä¸»æœº1 */ if(MBx_Master_RTU_Init(&MBxMaster, // ä¸»æœºå¯¹è±¡ SendPort, // å‘é€å‡½æ•° GetcPort, // æ¥æ”¶å‡½æ•° 9600, // æ³¢ç‰¹ç‡ NULL, // åº“å†…æ¥æ”¶bufferåˆ†é… 84, // æ¥æ”¶bufferæœ€å¤§é•¿åº¦ NULL, // åº“å†…å‘é€bufferåˆ†é… 84) // å‘é€bufferæœ€å¤§é•¿åº¦ ! MBX_API_RETURN_DEFAULT) { /* åˆå§‹åŒ–é”™è¯¯ è‡ªè¡Œåˆ¤æ–­è¿”å›å€¼å·®é”™ */ } MBx_Ticks(1); return 0; } ``` ### O0 ä¼˜åŒ– ```sh [build] [43/43 100% :: 2.056] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 22568 B 2 MB 1.08% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 21240 B 512 KB 4.05% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ``` ### O3ä¼˜åŒ– å…·å¤‡å¯åŠ¨æ–‡ä»¶å’Œmainå‡½æ•°ï¼Œåœ¨é…ç½®æ–‡ä»¶å¼€å¯äº†å®Œå…¨çš„åŠŸèƒ½ï¼Œå¦‚ä¸‹ ```sh [build] [43/43 100% :: 2.164] Linking C executable arm size test.elf [build] Memory region Used Size Region Size %age Used [build] FLASH: 11832 B 2 MB 0.56% [build] RAM_BLFlag: 0 GB 4 B 0.00% [build] DTCMRAM: 1540 B 131068 B 1.17% [build] RAM_D1: 21244 B 512 KB 4.05% [build] RAM_D2: 0 GB 288 KB 0.00% [build] RAM_D3: 0 GB 64 KB 0.00% ```"},"/modbusX/en/apidoc/tools/ç”¨æˆ·é…ç½®æ–‡ä»¶.html":{"title":"","content":" class: heading_no_counter draft: false # **User Configuration File** ## Key point The customization and configuration of the protocol stack should be an easy task to control the resource usage of the software package. In the `common/include` directory, there is a file named `MBx_user_sample.h`. Copy this file and rename it to `MBx_user.h`, and add it to a path that can be included. In the global compilation `define`, add **MBX_INCLUDE_USER_DEFINE_FILE**. This way, the library will use the custom definitions from `MBx_user.h` instead of the defaults. Since the configuration file complies with [CMSIS Configuration Wizard Annotations](https://open cmsis pack.github.io/Open CMSIS Pack Spec/main/html/configWizard.html)ï¼Œ, you can use the `vscode` plugin or other methods to render the configuration in `MBx_user.h`, allowing for a more intuitive configuration. The recommended method is to use the `Arm CMSIS Solution` plugin for `vscode`. Once installed, open the `MBx_user.h` file and click the \"Open Preview\" icon in the upper right corner to render the configuration file for graphical configuration. ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310833976_é…ç½®æ¸²æŸ“å…¥å£å›¾æ ‡.png) ![](https://cloudflare imgbed 6qt.pages.dev/file/1733310836815_é…ç½®æ¸²æŸ“.png) ## Particulars ### MBX_SLAVE_ENABLE Default 1 Whether the slave function is open, 1 is open, 0 is cut off the slave function ### MBX_MASTER_ENABLE é»˜è®¤ 1 Whether the master function is open, 1 is open, 0 is cut off the master function ### MBX_MODULE_TCP_MASTER_ENABLE Default 1 If you need to use the Modbus TCP master functionality, this macro should be set to 1. Otherwise, it is recommended to set it to 0, which will significantly reduce resource usage (mainly RAM). ### MBX_MASTER_REQUEST_QUEUE_MAX Default 40 The maximum number of entries in the host request queue for continuous read and write requests, stored and automatically sent for processing. This can significantly affect RAM usage. ### MBX_MASTER_MULTI_REG_MAX Default 127 The maximum number of multiple registers that the host can read and write to sets the maximum number of registers that can be specified for successive read or write instructions issued by the library, which significantly affects RAM usage. ### MBX_EXTEN_REG_HANDLE_ENABLE Default 0 Note that in the examples provided within the library, all different mapped variables require independent and as unique as possible handling functions. If you need to handle requests from different Modbus virtual addresses in a single handling function, this macro should be set to 1. When this macro is set to 1, the mapping table entries need to be modified (each entry will have an additional parameter set), and each write callback should be rewritten in a new way, which will be detailed later. A clear applicable scenario is when acting as a Modbus slave, but this slave is merely middleware that needs to control multiple identical module instances. Enabling this macro will greatly reduce the workload and lower maintenance difficulty. There are practical cases for such application scenarios. **The original mapping table** is as follows, where these three addresses control three identical modules: ```c {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower1,}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower2,}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower3,}, ``` You would need to write three almost identical callbacks, similar to the following. Although macros can be used to generate functions and other means, it is still difficult to maintain uniformly. ```c uint32_t ModbusModulePower1(void *value) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* Ignore some startup operations */ Powerflag[0] 1; } else { /* Ignore some shutdown operations */ Powerflag[0] 1; } return MBX_API_RETURN_DEFAULT; } ``` After enabling this macro, you need to **update this part of the mapping table** as follows: ```c const _MBX_REG_HANDLE_PARA MBXPara1 {.Para1 1, .Para2 1}; const _MBX_REG_HANDLE_PARA MBXPara2 {.Para1 2, .Para2 2}; const _MBX_REG_HANDLE_PARA MBXPara3 {.Para1 3, .Para2 3}; ...... {.Addr 0x2001, .Memory &(Powerflag[0]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara1}, {.Addr 0x2011, .Memory &(Powerflag[1]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara2}, {.Addr 0x2021, .Memory &(Powerflag[2]), .Type MBX_REG_TYPE_U8, .Handle ModbusModulePower, .Para &MBXPara3}, ``` Here, three global static variables are added as parameter sets, and each mapping entry needs to include the binding of the `.Para` part. This parameter set will be passed to the write handling function, allowing three identical modules to call the same function without needing to define three almost identical handling functions. Therefore, the definition of the handling function needs to be updated as follows: ```c uint32_t ModbusModulePower(void *value, _MBX_REG_HANDLE_PARA *para) { uint8_t ValueGet (*(uint8_t *)value); if(ValueGet > 0) { /* Perform startup operation for module identified by para >Para1 */ Powerflag[para >Para1 1] 1; } else { /* Perform shutdown operation for module identified by para >Para1 */ Powerflag[para >Para1 1] 1; } return MBX_API_RETURN_DEFAULT; } ``` For entries that do not use this parameter, the best approach is to set `.Para &DefaultPara`, where `DefaultPara` is a static variable generated when the macro is enabled, to avoid wild pointers."},"/modbusX/en/apidoc/apigengric/Addr_Map.html":{"title":"","content":" class: heading_no_counter draft: false # Creation of Address Tables A key feature of the library is to map Modbus addresses to existing variables. ![MBX_module.png](https://cloudflare imgbed 6qt.pages.dev/file/1733793623876_MBXæ¨¡å‹.png) Therefore, whether it's a master or a slave, an address mapping table needs to be created. For detailed instructions, it is recommended to refer to the library usage steps in the [project README file](https://github.com/stbanana/modbusX) ."},"/modbusX/en/no_translate.html":{"title":"no translation","content":" title: no translation class: md_page <div id \"visit_from\"></div> <div id \"no_translate_hint\">This page not translated yet</div> <div> <span id \"visit_hint\">Please visit</span> <a id \"translate_src\"></a> </div> <div> <script> function getQueryVariable(variable) { var query window.location.search.substring(1); var vars query.split(\"&\"); for (var i 0;i<vars.length;i++) { var pair vars[i].split(\" \"); if(pair[0] variable){return pair[1];} } return(false); } var ref getQueryVariable(\"ref\"); var from getQueryVariable(\"from\"); var link document.getElementById(\"translate_src\"); var fromDis document.getElementById(\"visit_from\"); link.href ref; link.text ref; fromDis.innerHTML from; </script> </div>"}}